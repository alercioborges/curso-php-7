Polimorfismo √© um dos pilares da Programa√ß√£o Orientada a Objetos (POO)**, ao lado de **abstra√ß√£o, encapsulamento e heran√ßa.

---

## ‚úÖ O que √© Polimorfismo?

A palavra polimorfismo vem do grego e significa "muitas formas".
Na programa√ß√£o, *polimorfismo √© a capacidade de um mesmo m√©todo ou interface se comportar de maneiras diferentes dependendo do contexto.

Ou seja, diferentes classes podem implementar o mesmo m√©todo de formas diferentes.

---

## ‚úÖ Para que serve?

O polimorfismo serve para:

* Tornar o c√≥digo mais **flex√≠vel** e **extens√≠vel**;
* Reduzir **acoplamento** entre as partes do c√≥digo;
* Facilitar a **manuten√ß√£o** e a **reutiliza√ß√£o** do c√≥digo;
* Permitir escrever **c√≥digo gen√©rico** que trabalha com objetos de diferentes classes.

---

## ‚úÖ Tipos de Polimorfismo

Existem dois tipos principais:

1. **Polimorfismo de Sobrescrita (Override)**: uma subclasse redefine um m√©todo da superclasse.
2. **Polimorfismo de Sobrecarga (Overload)**: o mesmo m√©todo com assinaturas diferentes (n√£o √© suportado diretamente em PHP).

> ‚ö†Ô∏è Em PHP, o polimorfismo mais comum √© o **de sobrescrita**, usando **interfaces** ou **heran√ßa**.

---

## ‚úÖ Exemplo com PHP

Vamos imaginar um sistema de envio de notifica√ß√µes.

### Passo 1: Criar uma interface comum

```php
interface Notificacao {
    public function enviar($mensagem);
}
```

### Passo 2: Criar diferentes classes que implementam essa interface

```php
class Email implements Notificacao {
    public function enviar($mensagem) {
        echo "Enviando e-mail: $mensagem\n";
    }
}

class SMS implements Notificacao {
    public function enviar($mensagem) {
        echo "Enviando SMS: $mensagem\n";
    }
}

class PushNotification implements Notificacao {
    public function enviar($mensagem) {
        echo "Enviando notifica√ß√£o push: $mensagem\n";
    }
}
```

### Passo 3: Usar polimorfismo

```php
function notificarUsuario(Notificacao $notificacao, $mensagem) {
    $notificacao->enviar($mensagem);
}

// Podemos passar qualquer objeto que implemente a interface Notificacao
notificarUsuario(new Email(), "Bem-vindo ao sistema!");
notificarUsuario(new SMS(), "Seu c√≥digo √© 1234");
notificarUsuario(new PushNotification(), "Voc√™ tem uma nova mensagem!");
```

---

## ‚úÖ O que aconteceu aqui?

* Criamos **v√°rias classes** que **implementam a mesma interface**.
* Todas t√™m o m√©todo `enviar()`, mas com **comportamentos diferentes**.
* A fun√ß√£o `notificarUsuario()` n√£o precisa saber qual classe foi usada: ela confia que o objeto vai se comportar corretamente.
  ‚Üí Isso √© **polimorfismo em a√ß√£o**!

---

## ‚úÖ Conclus√£o

* Polimorfismo √© essencial para trabalhar com **abstra√ß√µes**.
* Ele permite tratar **objetos diferentes de forma uniforme**.
* Em PHP, voc√™ usa **interfaces**, **heran√ßa** e **m√©todos sobrescritos** para aplic√°-lo.

-------------------------------------------------

Sim, **√© poss√≠vel usar polimorfismo em PHP sem implementar uma interface**.
Isso pode ser feito por meio de **heran√ßa de classes** ou at√© mesmo com **duck typing** (tipagem din√¢mica, estilo "se age como um pato, √© um pato").

---

## ‚úÖ 1. Polimorfismo com **heran√ßa** (sem interface)

Voc√™ pode definir uma **classe base** com um m√©todo e **sobrescrev√™-lo** nas classes filhas.

### Exemplo:

```php
class Notificacao {
    public function enviar($mensagem) {
        echo "Enviando notifica√ß√£o gen√©rica: $mensagem\n";
    }
}

class Email extends Notificacao {
    public function enviar($mensagem) {
        echo "Enviando e-mail: $mensagem\n";
    }
}

class SMS extends Notificacao {
    public function enviar($mensagem) {
        echo "Enviando SMS: $mensagem\n";
    }
}

function notificarUsuario(Notificacao $notificacao, $mensagem) {
    $notificacao->enviar($mensagem);
}

notificarUsuario(new Email(), "Mensagem por e-mail");
notificarUsuario(new SMS(), "Mensagem por SMS");
```

üëâ Aqui usamos **polimorfismo via heran√ßa**: todas as subclasses sobrescrevem o m√©todo `enviar()` da classe m√£e `Notificacao`.

---

## ‚úÖ 2. Polimorfismo com **duck typing** (sem interface nem heran√ßa)

PHP √© **linguagem fracamente tipada** e **din√¢mica**, ent√£o voc√™ pode ter uma fun√ß√£o que aceita qualquer objeto, desde que ele tenha o m√©todo esperado.

### Exemplo:

```php
class Email {
    public function enviar($mensagem) {
        echo "Enviando e-mail: $mensagem\n";
    }
}

class SMS {
    public function enviar($mensagem) {
        echo "Enviando SMS: $mensagem\n";
    }
}

function notificarUsuario($objeto, $mensagem) {
    if (method_exists($objeto, 'enviar')) {
        $objeto->enviar($mensagem);
    } else {
        echo "O objeto n√£o pode enviar mensagens.\n";
    }
}

notificarUsuario(new Email(), "Ol√° por e-mail");
notificarUsuario(new SMS(), "Ol√° por SMS");
```

üëâ Aqui, **n√£o usamos interface nem heran√ßa**, mas o m√©todo `enviar()` existe em ambos os objetos. Isso √© um tipo de polimorfismo chamado **polimorfismo por comportamento**, ou **duck typing**.

---

## ‚úÖ Conclus√£o

| Forma de polimorfismo em PHP | Requer interface? | Requer heran√ßa? | Seguro em tempo de compila√ß√£o? |
| ---------------------------- | ----------------- | --------------- | ------------------------------ |
| Interface                    | ‚úÖ Sim             | ‚ùå N√£o           | ‚úÖ Sim                          |
| Heran√ßa                      | ‚ùå N√£o             | ‚úÖ Sim           | ‚úÖ Sim                          |
| Duck typing                  | ‚ùå N√£o             | ‚ùå N√£o           | ‚ùå N√£o (verificado em runtime)  |

Voc√™ pode usar **qualquer uma das formas**, mas **interfaces e heran√ßa** oferecem mais **seguran√ßa de tipo** e **clareza** no c√≥digo.